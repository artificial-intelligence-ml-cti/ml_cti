# -*- coding: utf-8 -*-
"""laborator1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pxepMv2WlG9hnSkoG32ksU_UO-KlS4Eq

# Tutorial python
La adresa https://docs.python.org/3/tutorial/ se afla un scurt tutorial
despre Python. 
Alternativ puteti sa urmariti materialul urmator.
"""

x = 3
print(type(x))

# cel mai mare int in python ???
x = 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
print(x*x)

print(x + 1)
print(x - 1)
print(x * 2)
print(x ** 2)

x += 1
print(x)
x *= 2
print(x)

y = 2.5
print(type(y))
print(y, y + 1, y * 2, y ** 2)

"""# **Bool**: Pentru operatiile cu variabile de tip bool nu se folosesc simbolurile && si ||, ci and sau or."""

t = True
f = False
print(type(t))
print(t and f)
print(t or f)
print(not t)
print(t != f)

"""# **String** : Python ofera multe functii pentru sirurile de caractere."""

hello = 'hello' 
world = "world"

print(hello)
print(len(hello))

hw = hello + ' ' + world 
print(hw)

hw12 = '%s %s %d' % (hello, world, 12) 
print(hw12) 

s = "hello"
print(s.capitalize())
print(s.upper())
print(s.replace('l', '(ell)')) 

print(' hello \
world   \n\n \
'.strip() )

print(hw[0])
# stringurile nu sunt mutabile
hw[0] = 'x'

"""# **Liste**: O lista este echivalenta cu un vector, dar se poate redimensiona si poate contine elemente de tipuri diferite.

"""

xs = [3, 1, 2]
print(xs, xs[2])
print(xs[-1])
# listele sunt mutabile, elementele pot fi modificate intern
xs[2] = 'foo'
print(xs)
xs.append('bar')
xs += ['foobar']
print(xs)
# functiile append, pop, modifica intern o lista si nu returneaza o copie
x = xs.pop()
y = xs.pop(-1)
print(x, y, xs)

# listele sunt mutabile, o copie nu e o copie, ci o referinta la aceeasi
# adresa de memore
# https://developers.google.com/edu/python/lists
l1 = [1,2,3]
l2 = l1
l2.append(100)
print(l1)
print(id(l1))
print(id(l2))

from copy import copy
# copy face o copie
l2 = copy(l1)
l1.append(1000000)
print(l2)
# id-uri diferite
print(id(l1))
print(id(l2))

# listele sunt mutabile
def f(l):
  print(l)
  l.append(100)
  return 0

l = [1,2,3]
f(l)
# in urma apelului se modifica
print(l)

"""## **Slicing** – putem accesa o sublista a unei liste"""

nums = list(range(5))
print(nums)

print(nums[2:4])
print(nums[2:])
print(nums[:2])

print(nums[:])
print(nums[:-1])
print(nums[-2])

print(nums[::-1])

# un slice se poate asigna
nums[2:4] = [8, 9]
print(nums)

"""# **Loops**: Putem itera prin elementele unei liste in felul urmator:"""

animals = ['cat', 'dog', 'monkey']
for animal in animals:
  print(animal)

"""Daca vrem sa accesam indicele fiecarui element in corpul buclei, putem folosi functia **enumerate**."""

animals = ['cat', 'dog', 'monkey']
for idx, animal in enumerate(animals):
  print('#%d: %s' % (idx + 1, animal))

"""Daca avem doua liste X si Y si trebuie sa formam perechi (x i , y i ) cu elementele listelor putem folosi functia **zip**"""

X = [1, 2, 3, 4, 5]
Y = [9, 8, 7]
# inmultim listele element cu element (element wise)
xy_dot = [a * b for (a, b) in zip(X, Y)]
# se formeaza perechi cu al i-lea element din prima lista si 
# al i-lea din a doua lista
print(xy_dot)

"""## **List comprehensions**: Deseori vrem sa transformam un tip de date intr-un altul. 
Ca un exemplu, sa consideram urmatorul cod care calculeaza patratele numerelor:
"""

nums = [0, 1, 2, 3, 4]
squares = []
for x in nums:
  squares.append(x ** 2)
print(squares)

# Putem scrie codul mult mai scurt (nu neaparat mai simplu !!!) folosind list comprehensions:
nums = [0, 1, 2, 3, 4]
squares = [x ** 2 for x in nums]
print(squares)

# poate contine si conditii
nums = [0, 1, 2, 3, 4]
even_squares = [x ** 2 for x in nums if x % 2 == 0]
print(even_squares)

# folosim inmultirea ca truc sa obtinem int
bool_list = [True, False, True, True, False]
num_list = [x * 1 for x in bool_list]
print(num_list)

"""Pentru început, vă sugerăm să evitați folosirea codului într-o singură linie pentru a evita eventualele erori și pentru a fi mai ușor de făcut debug.

# **Dictionare**: Un dictionar stocheaza perechi (cheie, valoare).
"""

# dictionarele sunt mutabile
d = {'cat': 'cute', 'dog': 'furry'}
print(d['cat'])
print('cat' in d)
d['fish'] = 'wet'
print(d['fish'])

# o cheie lipsa declaneaza exceptie
print(d['monkey'])

print(d.get('monkey', 'default_value'))

d['cat'] = 'woohoo'
del d['cat']
print(d)

def f(dd):
  dd['wolf'] = 'nice'

# apelul unei functii poate altera dictionarul
f(d)
print(d)

from copy import copy
d = {'cat': 'cute', 'dog': 'furry'}
supra_d = {'d1':d, 'd2': {'alt':'dictionar'}}

c1 = copy(supra_d)
# o copie simpla nu se aplica recursiv pe obiectele din dictionar
del c1['d1']['dog']
print(d)

from copy import deepcopy
d = {'cat': 'cute', 'dog': 'furry'}
supra_d = {'d1':d, 'd2': {'alt':'dictionar'}}

c1 = deepcopy(supra_d)
# deepcopy se aplica si pe obiectele imutabile din dictionar
del c1['d1']['dog']
print(d)

# cheile si valorile nu sunt in format de liste:
print(type(d.keys()))
print(type(d.values()))
# trebuie convertite cu list( ... )
print(list(d.keys()))
print(list(d.values()))

# iterarea prin items()
for animal, legs in d.items():
  print(animal, '  --- ', legs )

"""# **Set**: Un set este o colectie neordonata de elemente unice (cum ar fi cheile unui dictionar fara valori)."""

animals = {'cat', 'dog'}
print('cat' in animals)
print('fish' in animals)
animals.add('fish')
print('fish' in animals)
print(len(animals))
animals.add('cat')
print(len(animals))
animals.remove('cat')
print(len(animals))

A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}
# union
print(A | B)
print(A.union(B))

# intersection
print(A & B)
print(A.intersection(B))

# diferenta
print(A - B)
print(A.difference(B))

# diferenta simetrica - elementele din reuniune care nu sunt in intersectie
print(A ^ B) # Afiseaza {1, 2, 3, 6, 7, 8}
A.symmetric_difference(B)

# unordered !!!
A[0]

# trebuie convertit in lista, dar nu ne garanteaza vreo ordine sortata
list(A)[0]

"""# **Tuples**: Un **tuplu** este o lista (immutable) ordonata de valori. Tuplu este foarte similar cu o lista, o diferenta fiind ca tuplul poate fi folosit drept cheie in dictionar si ca element a unui set, in schimb lista nu poate fi folosita."""

t1 = (1,2)
t2 = (2,3)
t3 = (1,2)
s = {t1, t2, t3}
# elementele unice
print(s)

d = {}
d[t1] = 'punct bun'
d[t2] = 'punct rau'
print(d)

t = (1,2,3,4,5,6)
t[0]

# !!! immutable
t[0] = 10

# trebuie convertit in lista
lt = list(t)
lt[0] = 10
print(lt)

def f(tt):
  tt = (1,2,3,3,3,4)
  return tt
# nu se modifica dupa apel
print(f(t))
print(t)

"""# **Functii**. In Python functiile sunt definite cu ajutorul cuvantului-cheie def."""

def hello(name, loud=False):
  if loud:
    print('HELLO, %s!' % name.upper())
  else:
    print('Hello, %s' % name)
hello('Bob') # Afiseaza "Hello, Bob"
hello('Fred', loud=True) # Afiseaza "HELLO, FRED!"

"""Vom defini o functie care primeste doua liste si returneaza True doar daca listele au lungimea diferita si elementul minim din prima lista nu se afla in a doua lista sau elementul minim din a doua lista se afla in prima lista, altfel va returna False."""

def my_function(first_list, second_list):
  if(len(first_list) == 0 or len(second_list) == 0):
    raise ValueError('Lists must not be empty!')
  min_first = min(first_list)
  min_second = min(second_list)
  if (min_first not in second_list or min_second in first_list) and len(first_list) != len(second_list):
    return True
  else:
    return False
first_list = [1, 2, 3, 4]
second_list = [0, 1, 3]
print(my_function(first_list, second_list)) # Afiseaza False

first_list = [-1, 1, 2, 3, 4]
second_list = [0, 1, 3]
print(my_function(first_list, second_list)) # Afiseaza True

first_list = [1, 2, 3, 4]
second_list = [0, 1, 3, 9]
print(my_function(first_list, second_list)) # Afiseaza False

first_list = [1, 2, 3, 4]
second_list = []
print(my_function(first_list, second_list)) # ValueError: Lists

import random # importul pachetului
def two_rand_nums():
  '''Dockblock:
  vom defini o functie care va returna doua numere naturale diferite generate aleator in intervalul [0, 5].
  '''
  a = random.randint(0, 5)
  b = random.randint(0, 5)
  while(a == b):
    print('a == b')
    b = random.randint(0, 5)
  return a, b

print(two_rand_nums())
# stringul pe care il scriem sub antetul functiei este mesaj de documentatite
# dockblock ce poate fi vizualizat prin help() sau .__doc__
print('help')
help(two_rand_nums)
print('__doc__')
print(two_rand_nums.__doc__)

"""# **Clase**: In definirea unei clase, fiecare metoda va avea ca prim argument self, iar accesarea atributele si metodelor in interiorul clasei se face cu self.atribut/ self.metoda()."""

class Greeter:
  # Constructor
  def __init__(self, name):
    self.name = name # Crearea unei instante
  # Metoda
  def greet(self, loud=False):
    if loud:
      print('HELLO, %s!' % self.name.upper())
    else:
      print('Hello, %s' % self.name)
  def __metoda_private(self):
    print('private')
  def _metoda_protected(self):
    print('protected')


g = Greeter('Fred') # Construieste un obiect de tipul Greeter
g.greet()
# Apeleaza metoda greet(); Afiseaza "Hello, Fred"

g.greet(loud=True)
# Apeleaza metoda greet(); Afiseaza "HELLO, FRED!"

# e private, nu?
g.__metoda_private()

g._metoda_protected()

"""# Exerciții de python
1. Scrieti o functie care primeste ca argument un numar natural n si afiseaza toti termenii din sirul lui Fibonacii mai mici decat n.
2. Scrieti o functie care verifica daca un numar natural n este prim.

# Exerciții pregătitoare pentru AI
1. Scrieți o funcție `def mul(x, w)` care returnează produsul scalar dintre x și w
2. Scrieți o funcție `def neuron_liniar(x, weights, bias)` care returnează produsul scalar dintre x*w la care se adună b
3. Implementați o funcție `def sigmoid(val)` care returnează valoarea funcției sigmoide https://en.wikipedia.org/wiki/Sigmoid_function
4. Impementați o funcție `def sign(val)` care returnează -1 dacă numărul este mai mic decât 0 și 1 dacă val este mai mare sau egal ca zero.
5. Să presupunem că avem valori de intrare pentru funcția AND
```
X_values = [
    [0, 0],
    [0, 1],
    [1, 0],
    [1, 1],
]
```
Alegeți la întâmplare niște `weights = [0, 0]` și un `bias = 0` apoi iterați prin valorile `X_values` și afișați rezultatul funcției `neuron_liniar`.
Ce valori trebuie să conțină weights și bias astfel încât funcția `sign` aplicată rezultatului `neuron_liniar` să returneze -1 dacă rezultatul AND este adevărat și 1 dacă este fals?

# Evaluating an AI
I. Se dau următoarele etichete prezise de un clasificator binar, `y_pred = [1, 1, 1, 0, 1, 0, 1, 1, 0, 0]` și etichetele `y_true = [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]`.
1. Definiti metoda `accuracy_score(y_true, y_pred)` care sa calculeze acuratetea clasificatorului binar.
2. Definiti metoda `precision_recall_score(y_true, y_pred)` care returneaza
precizia si recall-ul clasificatorului binar.

Urmariti mai multe detalii aici: https://en.wikipedia.org/wiki/Precision_and_recall#Definition_(classification_context)

II. Un algoritm de inteligență artificială prezice prețurile apartamentelor de 2 camere pentru 10 ani:
`y_pred = [45, 48, 53, 56, 54, 55, 58, 60, 63, 66]`. Prețurile reale au fost `y_true = [45, 45, 43, 41, 55, 58, 58, 58, 60, 59]`.
1. Definiti metoda `mse(y_true, y_pred)` (mean square error) care calculeaza media patratelor erorilor de clasificare.
2. Definiti metoda `mae(y_true, y_pred)` (mean absolute error) care calculeaza media erorii absolute de clasificare.

Mai multe detalii aici: https://en.wikipedia.org/wiki/Mean_squared_error#Predictor
"""