# -*- coding: utf-8 -*-
"""laborator2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15H7hUY7Xs44xJybnWO02sLHlyhOFFxSk

# Utilizarea bibliotecilor numpy si matplotlib
"""

! pip install numpy matplotlib

"""# Numpy"""

import numpy as np

"""## Creare np.arrays

### Initializați folosind o listă din Python
"""

a = np.array([1, 2, 3])
print(a)
# => [1 2 3]

print(type(a))
# tipul obiectului a => <class 'numpy.ndarray'>

print(a.dtype)
# tipul elementelor din a => int32

print(a.shape)
# tuple continand lungimea lui a pe fiecare dimensiune => (3,)

print(a[0])
# acceseaza elementul avand indexul 0 => 1

b = np.array([[1, 2, 3], [4, 5, 6]])
print(b.shape)
# => (2, 3)

print(b[0][2])
# => 3

print(b[0, 2])
# => 3

c = np.asarray([[1, 2], [3, 4]])
print(type(c))
# => <class 'numpy.ndarray'>

print(c.shape)
# => (2, 2)

"""### Creați folosind funcții din numpy"""

zero_array = np.zeros((3, 2))
print(zero_array)

ones_array = np.ones((2, 2))
print(ones_array)

constant_array = np.full((2, 2), 8)
print(constant_array)

identity_matrix = np.eye(3)
print(identity_matrix)

random_array = np.random.random((1,2))
print(random_array)

mu, sigma = 0, 0.1
gaussian_random = np.random.normal(mu, sigma, (3,6))
# https://en.wikipedia.org/wiki/Normal_distribution
print(gaussian_random)

first_5 = np.arange(5)
print(first_5)

"""## Indexare

### Slicing: extragerea unei submulțimi - trebuie specificați indecșii doriți pe fiecare dimensiune
"""

array_to_slice = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
print(array_to_slice)
slice = array_to_slice[:, 0:3]
# luam toate liniile si coloanele 0, 1, 2
print(slice)

#!!!!! slice-ul returneaza o parte din array la aceeasi adresa de memorie
slice[0][0] = 100
print(array_to_slice)

slice_copy = np.copy(array_to_slice[:, 0:3])
slice_copy[0][0] = 10000
print(slice_copy)
print(array_to_slice)

# la apelul unei functii un array se poate modifica accidental\
# daca nu se face copie
def f(ar):
  ar[0] = 0
  ar += 10

x = np.ones(10)
print(x)
f(x)
print(x)

"""În cazul în care unul din indecși este un întreg, dimensiunea
submulțimii returnate este mai mică decât dimensiunea inițială:
"""

slice_1 = array_to_slice[2:3, :]
print(slice_1)

slice_2 = array_to_slice[2, :]
print(slice_2)

slice_1d = np.ravel(slice_1)
print(slice_1d)

reshaped_array = np.reshape(array_to_slice, (2, 6))
print(reshaped_array)

"""## Indexare folosind vectori de întregi"""

array_to_slice = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
print(array_to_slice[[0,0], [1,3]])

"""### Indexare folosind vectori de valori bool:"""

bool_idx = (array_to_slice > 10)
print(bool_idx)
print(array_to_slice[bool_idx])
# direct pe array
print(array_to_slice[array_to_slice > 10])

"""## Funcții matematice
Operațiile matematice de bază sunt disponibile atât ca funcții NumPy
cât și ca operatori. Acestea sunt aplicate element cu element:
"""

x = np.array([[1,2],[3,4]], dtype=np.float64)
y = np.array([[5,6],[7,8]], dtype=np.float64)
print(x + y)
print(np.add(x, y))

print(x - y)
print(np.subtract(x, y))

print(x * y)
print(np.multiply(x, y))

print(x / y)
print(np.divide(x, y))

print(np.sqrt(x))

my_array = np.arange(5)
powered = np.power(my_array, 3)
print(powered)

"""### Produs scalar"""

x = np.array([[1, 2],[3, 4]])
y = np.array([[5, 6],[7, 8]])

v = np.array([9, 10])
w = np.array([11, 12])

print(v.dot(w))
print(np.dot(v, w))

print(np.matmul(x, v))
print(np.matmul(x, y))

"""### Operații pe matrici"""

my_array = np.array([[1, 2, 3], [4, 5, 6]])
print(my_array)
# transpose
print(my_array.T)

my_array = np.array([[1., 2.], [3., 4.]])
print(my_array)
# inversa
print(np.linalg.inv(my_array))

"""### **Axis** dispune de funcții care realizează operații pe o anumită
dimensiune.
"""

x = np.array([[1, 2],[3, 4]])
# suma pe o anumita dimensiune
print(np.sum(x))
# Suma tuturor elementelor => 10
print(np.sum(x, axis=0))
# Suma pe coloane => [4 6]
print(np.sum(x, axis=1))
# Suma pe linii => [3 7]
# putem specifica si mai multe axe pe care sa se faca operatia:
print(np.sum(x, axis=(0, 1)))
# Suma tuturor elementelor => 10

# matrice tridimensionala
y = np.array([[[1, 2, 3, 4], [5, 6, 7, 8]], [[1, 2, 3, 4], [5, 6, 7, 8]], [[1, 2, 3,
4], [5, 6, 7, 8]]])
print(y.shape) # shape e un tuplu cu 3 valori
print(y)

print(np.mean(y, axis=0)) # media pe axa 0
print(np.mean(y, axis=1)) # media pe axa 1
print(np.mean(y, axis=2)) # media pe axa 2

# indexul elementului maxim pe fiecare linie
z = np.array([[10, 12, 5], [17, 11 ,19]])
print(np.argmax(z, axis=1))

"""### Broadcasting
- mecanism care oferă posibilitatea de a realiza operații aritmetice între
vectori de dimensiuni diferite
- vectorul mai mic este multipilcat astfel încât să se potrivească cu cel
mai mare, operația fiind apoi realizată pe cel din urmă

[Reguli de broadcasting](https://numpy.org/doc/stable/user/basics.broadcasting.html)

Conform documetatiei: when operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing (i.e. rightmost) dimensions and works its way left. Two dimensions are compatible when either:

- they are equal 
- one of them is 1
"""

m = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
y = m + v
print(y)
# m si v se potrivesc pentru ca ultima dimensiune a lui m e egala cu cea a lui v
print(m.shape)
print(v.shape)
print(y.shape)

"""# Matplotlib"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure

"""## Plotare: cea mai importantă funcție este plot, care permite afișarea datelor 2D"""

x = np.arange(0, 3 * np.pi, 0.1)
y = np.sin(x)

# instatiem o figure
figure(figsize=(8, 6), dpi=80)
# Ploteaza punctele
plt.plot(x, y)
# Adauga etichete pentru fiecare axa
plt.xlabel('x axis label')
plt.ylabel('y axis label')
# Adauga titlu
plt.title('Sine')
# Adauga legenda
plt.legend(['Sine'])
# Afiseaza figura
plt.show()

"""OBS. Pentru a plota punctele independent, fără a face interpolare ca în
exemplul anterior, se poate specifica un al treilea parametru în funcția plot, astfel:
"""

figure(figsize=(8, 6), dpi=80)
plt.plot(x, y, 'o')

"""### Plotarea mai multor grafice în cadrul aceleiași figuri:"""

# Calculeaza coordonatele (x, y) ale punctelor de pe o curba sin, respectiv cos
# x - valori de la 0 la 3 * np.pi, luate din 0.1 in 0.1
x = np.arange(0, 3 * np.pi, 0.1)
y_1 = np.sin(x)
y_2 = np.cos(x)

figure(figsize=(8, 6), dpi=80)

# Ploteaza punctele in aceeasi figura
plt.plot(x, y_1)
plt.plot(x, y_2)
# Adauga titlu
plt.title('Sine and Cosine')
# Adauga legenda
plt.legend(['Sine', 'Cosine'])
# Afiseaza figura
plt.show()

x = np.arange(0, 3 * np.pi, 0.1)
y_1 = np.sin(x)
y_2 = np.cos(x)

# definim primul plot in figura 1
first_plot = figure(1, figsize=(8, 6), dpi=80)
plt.plot(x, y_1)
plt.title('Sine')
plt.legend(['Sine'])

# definim cel de-al doilea plot in figura 2
second_plot = figure(2, figsize=(8, 6), dpi=80)
plt.plot(x, y_2)
plt.title('Cosine')
plt.legend(['Cosine'])
# afisam figurile
plt.show()

"""### Sublotare: putem plota mai multe subfiguri în cadrul aceleiași figuri"""

x = np.arange(0, 3 * np.pi, 0.1)
y_sin = np.sin(x)
y_cos = np.cos(x)


figure(figsize=(10, 9), dpi=80)

# Creeaza un grid avand inaltimea 2 si latimea 1
# si seteaza primul subplot ca activ
plt.subplot(2, 1, 1)
# Ploteaza primele valori
plt.plot(x, y_sin)
plt.title('Sine')
# Seteaza cel de-al doilea subplot ca activ
# si ploteaza al doilea set de date
plt.subplot(2, 1, 2)
plt.plot(x, y_cos)
plt.title('Cosine')
# Afiseaza figura
plt.show()

"""# Exercitii A

1. Plotați implementarea funcției sigmoid din laboratorul anterior
2. Dacă `weights = [-2, 5]` si `bias = 0.2`, plotați dreapta corespunzătoare pentru o serie de puncte din spațiul bidimensional. Hint: folosiți [ecuația dreptei](https://sites.google.com/site/videomeditatii/clase-liceale-9-12/clasa-a-10-a/programa-scolara-pentru-matematica-clasa-a-x-a/ecuatia-dreptei-determinate-de-doua-puncte-distincte-din-plan) `x*w1 + y*w2 + bias = 0`

# Exercitii B

1. Se dau următoarele 9 imagini de dimensiuni 400x600. Valorile acestora au fost salvate în fișierele “images/car_{idx}.npy”.
"""

! rm -rf images*
! wget https://github.com/senisioi/artificial_intelligence_cti/raw/main/laborator2/images.zip
! unzip -o images.zip
! echo "*** Fisierele sunt: "
! ls images/
! echo "**** Calea catre directorul cu imagini este: "
! readlink -f images/
! echo "**** Un fisier npy contine: "
! head images/car_0.npy

"""------

1. Citiți imaginile din aceste fișiere și salvați-le într-un np.array (va avea dimensiunea 9x400x600). Citirea din fișier se face cu ajutorul funcției: `image = np.load(file_path)` Aceasta întoarce un np.array de dimensiune 400x600.
"""

# todo:
image = np.load('images/car_0.npy')

"""-----
2. Calculați suma valorilor pixelilor tuturor imaginilor.

"""

# todo:

"""----
3. Calculați suma valorilor pixelilor pentru fiecare imagine în parte.
"""

# todo:

"""----
4. Afișați indexul imaginii cu suma maximă.
"""

# todo:

"""----
5. Calculați imaginea medie și afișati-o.
Afișarea imaginii medii se poate face folosind biblioteca scikit-image în
următorul mod:
"""

! pip install scikit-image

from skimage import io

io.imshow(image.astype(np.uint8)) # petru a putea fi afisata
# imaginea trebuie sa aiba
# tipul unsigned int
io.show()

"""----
6. Cu ajutorul funcției `np.std(images_array)`, calculați deviația standard a
imaginilor.
"""

# todo:

"""----
7. Normalizați imaginile (se scade imaginea medie și se împarte rezultatul la deviația standard)
"""

# todo:

"""----
8. Decupați fiecare imagine, afișând numai liniile cuprinse între 200 și 300, respectiv coloanele cuprinse între 280 și 400.
"""

# todo: